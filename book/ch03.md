# 迈出第一步

&emsp;&emsp;使用c++开发服务的公司来，或多或少都会遇到一个问题，便是版本问题，2010年以后，随着c++便准的持续更新频率明显加快。
新特性带来编写程序的高性能和简单性，很多开发人员在开发中想尝试使用新的功能和特性。比如右值引用。明显可以带来性能上收益。同时，线上
服务器的版本，以及同服务器上部署的其他服务，兼容性是个非常棘手的问题。要升级c++的服务，需要的不仅仅是协调研发的同学，同时运维，测试，
相关的服务，都需要协调。当然我所指的是高性能，低延迟，对性能要求苛刻的服务，如果你的服务使用容器环境可以满足，可以忽律本这个议题。

&emsp;&emsp;从微服务的角度来看。

* 简易性部署

* 独立部署

* 异构性

&emsp;&emsp;在几十万行，甚至几百万行的项目中，修改一行代码，所带来的代价和影响也是非常大，运维不敢轻易上线，测试需要走完所有的
测试流程。经过线上灰度，回归，终于可以胆战心惊的进行上线操作，研发运维还要小心翼翼的跟踪线上服务若干时间，终于可以坐下来静静地点
支香烟了。为了尽量减少这种状态，通常，会积累多个需求，一次性进行上线操作。但是这种操作也是一枚巨大的炸弹，一次收集的问题越多，每一
次需要关注的内容就越多，就越容易出现纰漏。定位具体问题的难度，时间，牵涉人员都大幅增长。

&emsp;&emsp;在微服务的设计里，各个服务都是独立部署的。如果真的出现问题，只影响自己的服务，可以实现快速回滚。结合实际经验，有个疑问：
如果一个系统切分成很多微服务模块，并且如果系统是多套环境，那么引入的各个微服务版本组合就会非常多。这种情况下，各个微服务模块之间的版本
兼容性如何保证？

&emsp;&emsp;通常，有两类解决方案。一种是代码兼容大部分应用场景。另外一种是维护多个平台的服务，通过接口的设计链接各个服务。本项目采用
两种方式结合使用的方式。

## 代码治理

&emsp;&emsp;大多数公司，都有自己的一套编码规范。有一套规范是好的，大家一起遵守，来完成编码这件事。但制定规范的过程却不是那么快乐。我曾经
尝试过在google的编码规范基础上，结合我们业务需求，带领团队定制过相应的规范。对于参与制定规范的同事来说，作用还是很显著的。从命名规则到生命
周期的控制，到考虑性能的优化都能选择比较合适方式实现。随着团队的人员更迭。后来进入团队的同学，这方面的表现就不及前者，程序质量降低，bug比例
上升。静下来思考这个问题，一篇将近百业的规范文档，对程序员来说，毕竟不是需求文档，未必能从头读到结尾。更别说记住中间的细节要求。但是规范毕竟
是规范，是需要大家遵守的，从项目管理的角度，制度是必须要推行下去。中间与多位同学沟通，得到解决办法。

### 代码剪裁
&emsp;&emsp;所有核心功能逐步完善，也就是说，某人需要开发某业务，核心的组建是现成的。比如某同学的业务需求是实现一套http接口服务。当时有很多
种方式来实现。比如我们最终的实现方案是通过nginx模块结合lua完成项目。在做决定之前，基于nginx的服务监控，运维，测试以及发布测试等环境需要完整
存在，这也是我们日常工作技术积淀的考验。

### 更贴近程序员

&emsp;&emsp;除了书以外，我相信大多数程序员更愿意直接看到代码。从时间效率上说，一千字的文档说明，大约与几十行代码所展示的效果相当，如果能在代
码中稍微增加几行关键注释，效果更加明显。基于这样的事实，将文档规范，以关键业务的代码展示出来，收效就明显多了。建议使用上面提到的关键模块的代码
作为范例，更贴近业务。程序员阅读的机会更多。

### 更多范例

&emsp;&emsp;核心模块的该如何使用，在设计之初，或许某些场景出现情况还没有意识到，没有在这方面作出相应的解决方案，在新版本feature后，对failover的
场景要特别关注，增加测试用例和使用范例提醒后来人不要在继续踩下去。或者这个叫bug管理或者是例外管理更贴切一些。

## 持续集成

&emsp;&emsp;在开始正事的写代码之前，还要做一件事，让我们的项目能够自动的编译，测试，发布，也就是传说的持续集成。这部分我们主要关注自动编译和测试两
个环节。

### cmake集成单元测试

&emsp;&emsp;前面提到cmake，利用cmake构建c++项目。这部分继续深入使用cmake工具，使用cmake帮助我们构建程序，并且进行单元测试。cmake测试功能借助于
Ctest这个工具，在使用cmake编译工程时，Ctest会自动configure、build、test和展现测试结果。

&emsp;&emsp;要使用Ctest，首先CMakeLists.txt文件中需要enable_testing()操作。否则add_test命令并不起作用。在编译生成测试程序后，进行add_test，
即可将测试用例加入测试集中。本例中在test/ksl/CMakeLists.txt中：add_test(NAME test_type_traits COMMAND test_type_traits)。将
type_traits的单元测试加入到测试集中。在项目编译完成后，执行make test，即可运行测试。

### github集成

&emsp;&emsp;travis ci是一个很好的ci工具，于github能比较好的结合，设置包括passport。具体注册啥的官网网站以及互联网上有比较丰富的资源，这里就不在废话了。
用这个工具旨在建立一套完成的流程。

&emsp;&emsp;有了账号，设置好项目后，在自己的项目根目录下创建一个.travis.yml文件。目前的项目内容：

        language: cpp
        
        compiler:
        - gcc
        
        install:
        - ls 
        
        before_script:
        - cmake --version
        - mkdir build
        - cd build
        - cmake ../
        
        script:
        - make
        - make test
    
install这项没有任何事情做目前，搞个ls娱乐下。
提交github后，在https://travis-ci.org/gottingen/kob页面可以看到编译自动测试的情况。


## 内存管理与生命周期

&emsp;&emsp;工作中，经常会有同学讨论，我的程序core了，内存工作不正常了，内存泄漏等问题。
从正确使用内存的角度看，主要是集中在三个问题上。

* 内存边界

* 内存的生命周期管理

* 引用内存对象有效性。

&emsp;&emsp;内存边界问题，主要应用方式还是以c风格使用时出现机率比较大一些，比如使用sprintf,
等c风格操作，使用面向对象的方式操作内存，只要不是低级错误，出现问题机率相对小很多。

&emsp;&emsp;内存的生命周期管理，这个话题设计范围就比较广，对象的生命周期，内存池，线程内部内存池，
多线程同步等，特别是智能指针的出现，虽然从形式上解决了内存生命周期管理的问题，特别是在多线程环境下，
内存生命周期管理的复杂，也增加了很多不确定的问题，比如使用shared_ptr保护的对象，经过多个线程对象的share后，
如何精准控制，对象释放，如何同步对象内容，这些问题，在我们使用中也需要结合具体应用场景深入思考。有人要吐槽，既然
这么麻烦，我何必用c++来写程序呢，我用golang，用java等有gc的语言，让语言帮我完成这些操作就ok了。何必要苦大仇深
的去搞c++，所画的时间我可以去做很多业务逻辑。

&emsp;&emsp;这里并不去争论语言本身的好坏，从拥抱变化的角度来说，新鲜的事物，总有它去糟粕，留精华的价值点。也要感谢
这些制造变化的先驱者的努力。仅从如何写好程序来说，还是强调生命周期的管理，无论一门语言是否是带gc，如果对对象或者数据的
生命周期控制模糊，那程序的运行结果或许在某些情况下，运行的结果和预期并不能相符，甚至出现程序死掉等严重问题。

&emsp;&emsp;下面就以文件系统路径这个封装类，通过实例，看这个问题。

### path && path_view

&emsp;&emsp;path_view用来保存一个完整的文件路径，以unix系列文件路径表示为例。

* 可以获取到c风格string类型指针。系统调用如open，access等操作需要。
* 纠错，某些路径中包含因输入有误，包含多个分隔符，在经过path_view产出后，纠正此类错误。
* 获取父目录的功能。
* 生命周期内不修改局部路径，可以更改路径。
* 性能要求，构建过程中，最多允许两次内存拷贝。紧当需要纠错情况下，允许两次内存拷贝。（实际上，只经过一次拷贝也可以完成）

&emsp;&emsp;在编码之前，我们预设了集中应用场景，提出了具体的需求，功能性的需求，相信不会难倒任何一个人，可以说是史上
最近简单的需求。在日常的代码中，也实现过千万遍了。本例重点在于说明对内存生命中期的理解。在本例中还用到另外一个对象，
string_view。string_view是c++17中新引入数据结构。简而言之，这个类的核心作用是在不拷贝内存的情况下，对字符串进行只读
查找，引用，具体的api可以在c++ stl官方文档上查看，出于兼容，项目中实现了string_view，可以在低版本的c++中使用。

&emsp;&emsp;path_view 有几个数据成员
        
        数据类型定义：
        typedef  Char                                  value_type;
        typedef  ksl::basic_string_view<Char>          view_type;
        typedef  std::vector<string_view>              list_type;
        typedef  std::basic_string<Char>               string_type;
        typedef  Hash                                  hash_type;
        typedef  typename string_type::const_iterator  const_iterator;
        typedef  const_iterator                        iterator;
        数据成员定义
        string_type       _raw;
        list_type         _dirs;
        view_type         _name;
        hash_type         _hash;
        size_t            _hash_code;
        bool              _absolute;
        
        
_raw用于保存路径，_dirs用于保存各级目录，_name用于保存文件名。_dir的每个数据都是string_view
类型，为了减少占用空间使用和拷贝内存的消耗，指向的内存是_raw的实际存储空间。

&emsp;&emsp;在构造过程中，如构造函数 basic_path_view(std::string &&str),这里用到了右值引用。rvalue reference
是c++11新引入的语法，在提高性能方面有很大的帮助，简而言之，用交换内存指针，替代内存的拷贝，提升性能。使用这项技术可以显著的降低
memcpy的使用，提升性能。同时，也需要注意，不当的使用，会引出一些的程序问题。比如一种情况：str = "/root//abc/def/"

1. _raw通过交换内存指针，获得实参str内存以及大小。
通过路径解析函数解析_raw,将结果保存到_dirs等变量中。

2. 解析后发现_raw需要纠错,通过重构函数得到一个新的路径，并保存一个string_type中。

3. 出于性能考虑，使用string_type的rvalue拷贝构造，也就是交换了两个对象的内存。

4. 调用该对象，程序coredump。

&emsp;&emsp;这种做法，也是曾经某位core君在实际生产环境中出现的问题。当时的情况更极端一些，程序并没有core掉，而是在生产环境中，
产出的路径不是预期的结果，只有在极少数的情况下才会core掉。

&emsp;&emsp;先看具体的问题，这样的写法是有问题的，_dir中的成员引用的内存实际上是交换前的_raw内存地址，而交换后，实际上编程指向一个临时
string_type对象的内存地址。在后续的访问过程中，因为临时对象可能已经释放，很容易出现非法访问的情况。可能已经有同学已经猜到了，为什么线实际
使用的中，有不出core的情况--使用了内存池，在没有达到内存上线的情况下，内存还是用户有所有权的，只有在内存使用超过池子上线，释放掉的情况，才会
出现core的情况。

&emsp;&emsp;有人可能会问，在上线之前没有测试嘛，这很容易测试出来的。前面已经说过，使用内存池的技术，隐藏了这一个重大的问题。另外，测试方面
确实是做的不够全面。本身，这个类或者功能与内存池是无关的。大部分我们的测试都是集成测试，在集成环境下，我们去做这测试，特别是压力不够，内存池
达不到阀值的情况下，问题就会被隐藏掉。测试并不是万能，当时可以结合代码覆盖率来完善检查程序的质量，但本质上解决代码的质量问题，还是需要人去解决。
没有一个完整的工具，保证整个研发过程中，无bug出现。只能尽量降低bug的数量，降低对生产环境的影响。

&emsp;&emsp;从经验来说，要避免上述的问题，在开发过程中，我们要做些什么呢。从设计开发的角度来说，接口独立性，生命周期清晰。是设计的重点。

* 接口对生命周期的影响，接口需要访问数据成员，接口的调用是通过对象来调用。同时，不同线程空间对接口的调用，会影响数据成员的内容，对内容的同步性
有比较强烈的要求。如上列，即使是在同一个线程空间中，也可能会出现某些意想不到的问题。

* 保证数据同步，指向清晰，特别数对代理类型的数据成员，比如指针成员，引用成员，特别是侵入式代理， 数据成员的内容修改是否会影响要做完整的生命周期分析。

以上面例子为例，修改_raw交换内存后，_dir单元的内容实际上已经失效，指向的内存空间实际上已经无效。构建过程，分为解析阶段，纠错阶段两大块，在设计中，
需要提出几个问题。

* 两个过程中有内存内容修改吗？
* 两个过程中有内存指针改变吗？

解析过程是只读过程，不会有上述变化，纠错过程中，可能会发生指针改变。进一步分析，指针改变对其他数据成员有印象么，会发现对_dir，以及_name都会有影响。
到这一步，下面该如何实现，也是水到渠成的问题。

&emsp;&emsp;上面相当于我们一起踩过一个小坑，通过仔细分析整个过程，我们发现，在开发过程中，关注的点大部分集中在功能的实现上，确是缺少最核心的一步，
确认生命周期，同步，边界的思考。在开发之前，花一刻钟时间把这三个问题在"人脑"中运行一遍，相信对设计大有裨益。

&emsp;&emsp;测试虽然不是万能的，大多数的case，还是可以通过测试发现问题。前面也提到过集成单元测试的问题，在完成代码后，通过预设的单元测试case是必要
的步骤。这里也不得不提下，代码覆盖率问题。要注意case的代码覆盖率，也有相应的工具检测代码的覆盖率。在范型编程的情况，特别要注意代码覆盖率问题，因为在没有
调用的情况下，部分实现，在编译链接过程中，并不实例化，本该编译不通过的源码，竟然可以在线上活蹦乱跳。特别是开发基础库的同学，不同业务的不同需求，可能导致部分
业务可用，部分业务不可用的情况。尽量保证单元测试的覆盖率！

## 性能

&emsp;&emsp;对path_view类， 已经正确的完成了功能，从性能方面考虑，是不是已经做到完美了？很多geek的小伙伴已经想到我要说什么。没错，是内存拷贝，在有纠错的情况下，
这样的实现需要经过两次内存拷贝，两次解析，实际上，我们只需要一次内存拷贝，解析也不需要两次，一次就可以完成。在修改一下上面的需求，功能性需求就不在赘述，性能方面。

* 不申请额外内存。
* 不得修改输入内存。
* 拷贝不超过一次，（部分情况不需要拷贝）
* 算法复杂读O(n), 系数 k < 2;也就是遍历输入数据不超过2遍。

经过步步为营的持续优化，对path_view类几乎是达到了功能和性能上的完善。达到基础库的标准。注意我用的是"几乎"这个词，那是不是意味还有优化空间呢。答案是有的，虽然这部分，
在实际上我未必会去做，也有必要提一下。两方面，

* 设计上，设计更加轻量级的类，只做pointer的引用，不修改任何内容，当着这样做的前提是保证路径的正确性。
* 编码方面，考虑cpu的亲和性，比如在解析过程成中不可避免要使用if else语句，大部分情况，字符都不会是路径分割符'/'，在cpu寄存器方面可以做稍微的优化。
* 编译器优化，最终我们的输入只有一个内存指针，如__restrict等编译器优化指令，能帮助编译器作出优化指示。
