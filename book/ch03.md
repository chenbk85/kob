# 迈出第一步

&emsp;&emsp;使用c++开发服务的公司来，或多或少都会遇到一个问题，便是版本问题，2010年以后，随着c++便准的持续更新频率明显加快。
新特性带来编写程序的高性能和简单性，很多开发人员在开发中想尝试使用新的功能和特性。比如右值引用。明显可以带来性能上收益。同时，线上
服务器的版本，以及同服务器上部署的其他服务，兼容性是个非常棘手的问题。要升级c++的服务，需要的不仅仅是协调研发的同学，同时运维，测试，
相关的服务，都需要协调。当然我所指的是高性能，低延迟，对性能要求苛刻的服务，如果你的服务使用容器环境可以满足，可以忽律本这个议题。

&emsp;&emsp;从微服务的角度来看。

* 简易性部署

* 独立部署

* 异构性

&emsp;&emsp;在几十万行，甚至几百万行的项目中，修改一行代码，所带来的代价和影响也是非常大，运维不敢轻易上线，测试需要走完所有的
测试流程。经过线上灰度，回归，终于可以胆战心惊的进行上线操作，研发运维还要小心翼翼的跟踪线上服务若干时间，终于可以坐下来静静地点
支香烟了。为了尽量减少这种状态，通常，会积累多个需求，一次性进行上线操作。但是这种操作也是一枚巨大的炸弹，一次收集的问题越多，每一
次需要关注的内容就越多，就越容易出现纰漏。定位具体问题的难度，时间，牵涉人员都大幅增长。

&emsp;&emsp;在微服务的设计里，各个服务都是独立部署的。如果真的出现问题，只影响自己的服务，可以实现快速回滚。结合实际经验，有个疑问：
如果一个系统切分成很多微服务模块，并且如果系统是多套环境，那么引入的各个微服务版本组合就会非常多。这种情况下，各个微服务模块之间的版本
兼容性如何保证？

&emsp;&emsp;通常，有两类解决方案。一种是代码兼容大部分应用场景。另外一种是维护多个平台的服务，通过接口的设计链接各个服务。本项目采用
两种方式结合使用的方式。

## 代码治理

&emsp;&emsp;大多数公司，都有自己的一套编码规范。有一套规范是好的，大家一起遵守，来完成编码这件事。但制定规范的过程却不是那么快乐。我曾经
尝试过在google的编码规范基础上，结合我们业务需求，带领团队定制过相应的规范。对于参与制定规范的同事来说，作用还是很显著的。从命名规则到生命
周期的控制，到考虑性能的优化都能选择比较合适方式实现。随着团队的人员更迭。后来进入团队的同学，这方面的表现就不及前者，程序质量降低，bug比例
上升。静下来思考这个问题，一篇将近百业的规范文档，对程序员来说，毕竟不是需求文档，未必能从头读到结尾。更别说记住中间的细节要求。但是规范毕竟
是规范，是需要大家遵守的，从项目管理的角度，制度是必须要推行下去。中间与多位同学沟通，得到解决办法。

### 代码剪裁
&emsp;&emsp;所有核心功能逐步完善，也就是说，某人需要开发某业务，核心的组建是现成的。比如某同学的业务需求是实现一套http接口服务。当时有很多
种方式来实现。比如我们最终的实现方案是通过nginx模块结合lua完成项目。在做决定之前，基于nginx的服务监控，运维，测试以及发布测试等环境需要完整
存在，这也是我们日常工作技术积淀的考验。

### 更贴近程序员

&emsp;&emsp;除了书以外，我相信大多数程序员更愿意直接看到代码。从时间效率上说，一千字的文档说明，大约与几十行代码所展示的效果相当，如果能在代
码中稍微增加几行关键注释，效果更加明显。基于这样的事实，将文档规范，以关键业务的代码展示出来，收效就明显多了。建议使用上面提到的关键模块的代码
作为范例，更贴近业务。程序员阅读的机会更多。

### 更多范例

&emsp;&emsp;核心模块的该如何使用，在设计之初，或许某些场景出现情况还没有意识到，没有在这方面作出相应的解决方案，在新版本feature后，对failover的
场景要特别关注，增加测试用例和使用范例提醒后来人不要在继续踩下去。或者这个叫bug管理或者是例外管理更贴切一些。

## 持续集成

&emsp;&emsp;在开始正事的写代码之前，还要做一件事，让我们的项目能够自动的编译，测试，发布，也就是传说的持续集成。这部分我们主要关注自动编译和测试两
个环节。

### cmake集成单元测试

&emsp;&emsp;前面提到cmake，利用cmake构建c++项目。这部分继续深入使用cmake工具，使用cmake帮助我们构建程序，并且进行单元测试。cmake测试功能借助于
Ctest这个工具，在使用cmake编译工程时，Ctest会自动configure、build、test和展现测试结果。

&emsp;&emsp;要使用Ctest，首先CMakeLists.txt文件中需要enable_testing()操作。否则add_test命令并不起作用。在编译生成测试程序后，进行add_test，
即可将测试用例加入测试集中。本例中在test/ksl/CMakeLists.txt中：add_test(NAME test_type_traits COMMAND test_type_traits)。将
type_traits的单元测试加入到测试集中。在项目编译完成后，执行make test，即可运行测试。

### github集成

&emsp;&emsp;travis ci是一个很好的ci工具，于github能比较好的结合，设置包括passport。具体注册啥的官网网站以及互联网上有比较丰富的资源，这里就不在废话了。
用这个工具旨在建立一套完成的流程。

&emsp;&emsp;有了账号，设置好项目后，在自己的项目根目录下创建一个.travis.yml文件。目前的项目内容：

        language: cpp
        
        compiler:
        - gcc
        
        install:
        - ls 
        
        before_script:
        - cmake --version
        - mkdir build
        - cd build
        - cmake ../
        
        script:
        - make
        - make test
    
install这项没有任何事情做目前，搞个ls娱乐下。
提交github后，在https://travis-ci.org/gottingen/kob页面可以看到编译自动测试的情况。

## 性能优化

&emsp;&emsp;ksl部分主要关注性能的两方面，cpu、内存。在后面的具体的代码中，将结合具体的实现，
解决减少内存拷贝，内存碎片，内存泄漏检测等。